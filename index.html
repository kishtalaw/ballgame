<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Tilt Ball Game</title>
<style>
  body { margin: 0; overflow: hidden; }
  canvas { background: #222; display: block; }
</style>
</head>
<body>

<canvas id="game"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let level = 1;
let levelTimer = 0;
let levelTextVisible = false;

let ball = { x: 50, y: 50, r: 20, vx: 0, vy: 0 };
let target = { x: 300, y: 300, r: 25 };
let walls = [];

const GRID_ROWS = 6;
const GRID_COLS = 10;

function randomInRange(min, max) {
    return Math.random() * (max - min) + min;
}

function generateWalls() {
    walls = [];

    const cellWidth = canvas.width / GRID_COLS;
    const cellHeight = canvas.height / GRID_ROWS;

    let maxWalls = Math.min(level * 2, GRID_ROWS * GRID_COLS - 4); // 4 safe cells

    let usedCells = new Set();

    while (walls.length < maxWalls) {
        let r = Math.floor(Math.random() * GRID_ROWS);
        let c = Math.floor(Math.random() * GRID_COLS);
        let cellKey = r + "," + c;

        // Skip duplicates or near ball/target zone
        if (usedCells.has(cellKey)) continue;
        let cellX = c * cellWidth;
        let cellY = r * cellHeight;

        if (Math.abs(cellX - ball.x) < 100 && Math.abs(cellY - ball.y) < 100) continue;
        if (Math.abs(cellX - target.x) < 100 && Math.abs(cellY - target.y) < 100) continue;

        usedCells.add(cellKey);

        // Random wall size inside the cell
        let wallW = randomInRange(cellWidth * 0.5, cellWidth * 0.9);
        let wallH = randomInRange(20, 60);

        walls.push({
            x: cellX + randomInRange(0, cellWidth - wallW),
            y: cellY + randomInRange(0, cellHeight - wallH),
            width: wallW,
            height: wallH
        });
    }
}

function newTarget() {
    target.x = Math.random() * (canvas.width - target.r * 2) + target.r;
    target.y = Math.random() * (canvas.height - target.r * 2) + target.r;
}

function startNewLevel() {
    level++;
    ball.x = 50;
    ball.y = 50;
    ball.vx = 0;
    ball.vy = 0;
    newTarget();
    generateWalls();
    levelTimer = 60;  // frames (~1 sec)
    levelTextVisible = true;
}

function showLevelText() {
    if (!levelTextVisible) return;
    ctx.fillStyle = "rgba(255,255,255,0.8)";
    ctx.font = "48px sans-serif";
    ctx.textAlign = "center";
    ctx.fillText("LEVEL " + level, canvas.width / 2, 60);
    levelTimer--;
    if (levelTimer <= 0) {
        levelTextVisible = false;
    }
}

window.addEventListener("deviceorientation", (e) => {
    const gX = e.gamma;
    const gY = e.beta;
    ball.vx += gX * 0.05;
    ball.vy += gY * 0.05;
});

function checkCollisionWithWalls() {
    for (const wall of walls) {
        if (
            ball.x + ball.r > wall.x &&
            ball.x - ball.r < wall.x + wall.width &&
            ball.y + ball.r > wall.y &&
            ball.y - ball.r < wall.y + wall.height
        ) {
            // Handle collision
            if (
                ball.y > wall.y &&
                ball.y < wall.y + wall.height
            ) {
                if (ball.x < wall.x) ball.x = wall.x - ball.r;
                else ball.x = wall.x + wall.width + ball.r;
                ball.vx *= -0.7;
            }

            if (
                ball.x > wall.x &&
                ball.x < wall.x + wall.width
            ) {
                if (ball.y < wall.y) ball.y = wall.y - ball.r;
                else ball.y = wall.y + wall.height + ball.r;
                ball.vy *= -0.7;
            }
        }
    }
}

function update() {
    ball.x += ball.vx;
    ball.y += ball.vy;
    ball.vx *= 0.98;
    ball.vy *= 0.98;

    if (ball.x - ball.r < 0 || ball.x + ball.r > canvas.width) ball.vx *= -0.8;
    if (ball.y - ball.r < 0 || ball.y + ball.r > canvas.height) ball.vy *= -0.8;

    checkCollisionWithWalls();

    const dx = ball.x - target.x;
    const dy = ball.y - target.y;
    if (Math.sqrt(dx * dx + dy * dy) < ball.r + target.r) {
        startNewLevel();
    }
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Target
    ctx.fillStyle = "lime";
    ctx.beginPath();
    ctx.arc(target.x, target.y, target.r, 0, Math.PI * 2);
    ctx.fill();

    // Ball
    ctx.fillStyle = "red";
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
    ctx.fill();

    // Walls
    ctx.fillStyle = "white";
    walls.forEach(w => {
        ctx.fillRect(w.x, w.y, w.width, w.height);
    });

    showLevelText();
}

function loop() {
    update();
    draw();
    requestAnimationFrame(loop);
}

newTarget();
generateWalls();
loop();
</script>

</body>
</html>
